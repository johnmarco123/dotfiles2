#/usr/bin/env bash

# the directory in which the tmux-sessionizer state will be stored
script_dir="$HOME"
# the file where the tmux-sessionizer data will be stored
file_name=".tmux-sessionizer.txt"
full_path="$script_dir/$file_name" 

# create the tmux-sessionizer state file that remembers what directories to
# show
if [[ ! -e "$full_path" ]]; then
    touch "$full_path"
fi

# Write any commands here which will add directories that you want to stay
# up-to-date. Since directories are usually added to $HOME it is probably a
# good idea to keep the initial example
commands=(
    # Example command
    "find $HOME -maxdepth 1 -type d"
)

combined_results=""

# Gather the results of all the commands
for cmd in "${commands[@]}"; do 
    combined_results+=$(eval "$cmd"; echo)
done

# if there were any results for the commands we add it to the tmux-sessionizer
# list, but we also ensure no duplicates are added
if [[ -n "$combined_results" ]]; then
    temp_file=$(mktemp)
    if { echo "$combined_results"; cat "$full_path"; } | sort -u > "$temp_file"; then
        mv "$temp_file" "$full_path"
    else
        echo "Error: Failed to create sorted output."
        rm -f "$temp_file"
    fi
fi


#adding, deleting or listing the tmux-sessionizer list
if [[ $# -eq 1 ]]; then

    # add a path to our tmux save file, this accepts stdin and also prevents
    # duplicates
    if [[ $1 == -add || $1 == -a ]]; then
        while read line; do
            # remove trailing slashes before comparing
            line="${line%/}"
            # ensure that the filepath is absolute and it exists
            if [[ -d $line && "$line" = /* ]]; then
                if ! grep -qFx $line $full_path ; then
                    echo "$line" >> $full_path
                fi
            fi
        done < "${2:-/dev/stdin}"

    # delete a path from our tmux save file. You can select multiple files to
    # delete using the tab key in fzf to select multiple
    elif [[ $1 == -delete || $1 == -d ]]; then
        while true; do
            selected=$(cat "$full_path" | fzf -m --cycle --scroll-off 10)

            if [[ -z "$selected" ]]; then
                exit 0
            fi

            count=$(echo "$selected" | wc -l)

            if [[ $count -gt 0 ]]; then
                temp_file=$(mktemp)
                grep -v -F -x -e "$selected" "$full_path" > "$temp_file"
                mv "$temp_file" "$full_path"
            fi
        done
    # simply lists all paths in your tmux-sessionizer list to standard out
    elif [[ $1 == -list || $1 == -l ]]; then
        cat $full_path
    fi
    exit 0
fi


# remove any directories in the tmux-sessionizer list that no longer exist
valid_paths=$(mktemp)
while read -r line; do
    if [[ -d "$line" ]]; then
        echo "$line" >> $valid_paths
    fi
done < "$full_path"
mv "$valid_paths" "$full_path"


# switching tmux to the files
switch_to() {
    if [[ -z $TMUX ]]; then
        tmux attach-session -t $1
    else
        tmux switch-client -t $1
    fi
}

has_session() {
    tmux list-sessions | grep -q "^$1:"
}

hydrate() {
    if [ -f $2/.tmux-sessionizer ]; then
        tmux send-keys -t $1 "source $2/.tmux-sessionizer" c-M
    elif [ -f $HOME/.tmux-sessionizer ]; then
        tmux send-keys -t $1 "source $HOME/.tmux-sessionizer" c-M
    fi
}

if [[ $# -eq 1 ]]; then
    selected=$1
else
    selected=$(cat $full_path | fzf --cycle --scroll-off 10)
fi

if [[ -z $selected ]]; then
    exit 0
fi

selected_name=$(basename "$selected" | tr . _)
tmux_running=$(pgrep tmux)

if [[ -z $TMUX ]] && [[ -z $tmux_running ]]; then
    tmux new-session -s $selected_name -c $selected
    hydrate $selected_name $selected
    exit 0
fi

if ! has_session $selected_name; then
    tmux new-session -ds $selected_name -c $selected
    hydrate $selected_name $selected
fi

switch_to $selected_name
